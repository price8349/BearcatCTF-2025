# sqRSA
To solve this you will want to use the Chinese Remainder Theorem to retrieve possible plaintexts.

```python
from Crypto.Util.number import long_to_bytes, inverse

e = 2
p = 8946541176074654913817717054410771331419218032593785296134838490312525894218240553305396599307555077734655624876704161811830296918000348456470769765921767
q = 8932929811422923151480388874853984777290071075825590049173830382535883452482114410463430296988680318519251836647527145507992221700683938654669731212502879
n = 79918824380879984230214478212107859789970760434299554608805294793725784734356035450441094355662829397276452220713697299759466084320223642049726452788651518853937184518959195516619507938497758925978032369947277889352888108330331269331130005097469138112607532759174992940835608455793923500626923539208576267193
c = 17349894155329354363328734000800652637346887108866919240446747423455120556394923514564284438906649577094462846372316919957176356395706169922421515974398971844608693078173465906525109301576180786133798467234128571459625488335621909834995712400917418963473920470534646258784866422718709370743346105151573384808

r_p = pow(c, (p+1)//4, p)
r_q = pow(c, (q+1)//4, q)

def crt(a, b, p, q):
    inv_p_mod_q = inverse(p, q)
    x = (a + p * ((b - a) * inv_p_mod_q % q)) % (p * q)
    return x

r1 = crt(r_p, r_q, p, q)
r2 = crt(r_p, (-r_q) % q, p, q)
r3 = (-r1) % n
r4 = (-r2) % n

candidates = [r1, r2, r3, r4]
for i, cand in enumerate(candidates, start=1):
    flag = long_to_bytes(cand)
    if b'BCCTF' in flag:
        print(flag)
#BCCTF{Don7_b3_4_squArE_ac6c54f792c90a69b8}
```